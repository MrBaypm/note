    DataBinding 的核心是通过注解处理器（APT）在编译期自动生成绑定类，将布局中的 View 和数据对象建立映射，再通过观察者模式实现数据和 UI 的双向同步，全程无需手动 findViewById 和设置数据，
底层是注解处理 + 反射 / 直接调用 + 观察者模式的组合实现。


<?xml version="1.0" encoding="utf-8"?>
<!-- DataBinding 核心：根标签必须是 layout，替代传统的 LinearLayout/ConstraintLayout -->
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 数据变量区：定义布局中要绑定的数据对象，对应 BR.user 生成 -->
    <data>
        <!-- 定义变量名 user，类型为自定义的 User 实体类（需写全类名） -->
        <variable
            name="user"
            type="com.example.databindingdemo.User" />
    </data>

    <!-- 实际 UI 布局：使用 ConstraintLayout 作为根布局（推荐），内部放需要绑定的 View -->
    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity">

        <!-- 绑定 User 的 name 属性：@{user.name} 是 DataBinding 核心表达式 -->
        <TextView
            android:id="@+id/tv_name" <!-- 带 id，编译期生成绑定类的成员变量 tvName -->
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{user.name}" <!-- 数据→UI 单向绑定 -->
            android:textSize="20sp"
            android:textColor="#333333"
            tools:text="默认名称" <!-- 预览布局用，不影响运行时 -->
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

    </androidx.constraintlayout.widget.ConstraintLayout>
</layout>


生成类的简化示例（对应activity_main.xml，包含tv_name和user变量）：
// 自动生成的绑定类，继承自ViewDataBinding（DataBinding的基类）
public class ActivityMainBinding extends ViewDataBinding {
    // 布局中带id的View，直接作为成员变量（编译期初始化，无反射）
    public final TextView tvName;
    // 数据对象的引用
    private User mUser;
    // 标记是否需要重新执行绑定（优化性能，避免重复刷新）
    private boolean mDirtyFlags = true;

    // 构造方法：初始化View、绑定LayoutInflater
    protected ActivityMainBinding(LayoutInflater inflater, ViewGroup root) {
        super(inflater, root);
        // 编译期自动生成的View初始化逻辑，替代findViewById
        this.tvName = root.findViewById(R.id.tv_name);
        // 给View设置标签，关联绑定类（用于后续查找）
        this.tvName.setTag(null);
    }

    // 给绑定类设置数据对象的setter方法
    public void setUser(User user) {
        this.mUser = user;
        // 标记数据变化，需要刷新UI
        this.mDirtyFlags = true;
        // 触发绑定逻辑执行
        notifyChange();
    }

    // 核心：执行数据和View的绑定，由DataBinding框架调用
    @Override
    protected void executeBindings() {
        // 双重校验：避免多线程重复执行，优化性能
        synchronized (this) {
            if (!mDirtyFlags) return;
            mDirtyFlags = false;
        }
        // 解析绑定表达式：@{user.name}，获取数据并赋值给View
        String userName = mUser == null ? "" : mUser.getName();
        // 给View设置数据，完成UI刷新
        this.tvName.setText(userName);
    }
}


常用初始化代码：
// Activity中初始化
ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
// Fragment中初始化
ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater(), container, false);

DataBinding 的底层实现是编译期 APT 注解处理和运行期观察者模式的结合，核心流程可概括为 3 句话：
编译期：注解处理器解析 DataBinding 布局，自动生成XXXBinding 绑定类和BR 标识类，绑定类持有 View 引用并实现数据绑定逻辑；
运行期：通过 DataBindingUtil 初始化绑定类（仅一次反射），将数据对象设置给绑定类，通过BaseObservable/ObservableField实现数据观察；
同步逻辑：数据变化时触发通知，绑定类执行executeBindings()将数据赋值给 View（数据→UI）；双向绑定则通过 View 的事件监听器实现 UI 变化更新数据（UI→数据），完成双向同步。
简单来说，DataBinding 的本质是框架替你手写了 findViewById、数据设置、UI 监听的代码，让开发者从繁琐的 UI 操作中解放，同时通过编译期优化保证了性能。
